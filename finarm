#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# finarm - Financial Armageddon
# Keeps track of the value of a currency and precious metals portfolio using
# prices retrieved from Yahoo Finance.

# Copyright 2015 Andrea Chiavazza

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Just enter the amount of assets you own below.
# Look at the options below for further customizations.

# If you find this program useful, you can donate to the
# bitcoin address 12f1khXXGp6vW6NizjRdfTgZDGWJdrna8i

########################### USER EDITABLE VARIABLES ############################

# Quantities of currencies in the portfolio.
# The metals defined by ISO 4217 are:
# XAU (gold), XAG (silver), XPD (palladium), XPT (platinum)
# XBT (bitcoin) is being evaluated for inclusion in the ISO 4217 standard.
# For all currency symbols see: http://en.wikipedia.org/wiki/ISO_4217
# Currency quantities must be defined by a number.
# Metal quatities must be defined by a map of weight units to quatities.
XAU_G =  (20 * 1 +
          10 * 1 +
           1 * 1)

XAG_G = (1000 * 1 +
          100 * 1)

PORTFOLIO = {
    'XAU': {'g': XAU_G, 'ozt': 1},
    'XAG': {'g': XAG_G, 'ozt': 1},
    'XBT': 1,
    'GBP': 1,
}

# Weight units for the metal quantities in the portfolio.
# Allowed values are: 'mg' 'g' 'kg' 't' 'ozt'.
WEIGHT_UNITS = ('g', )

# Which currencies to use for the displayed prices.
PRICE_CURS = ('USD', 'EUR', 'GBP', )

# Which currencies to use to compute the total value of the portfolio.
TOTAL_CURS = ('USD', 'EUR', 'GBP', 'XBT', 'XAU', )

# Whether to display the currencies from highest to lowest of their value in the portfolio.
DISPLAY_HIGHEST_TO_LOWEST = True

# How many significant digits to use for all displayed values.
SIGNIF_DIGITS = 4

# Separator used to separate the fractional part.
FRACT_SEPARATOR = "."

# Separator used to group the thousands. Use "" to have no thousand separators.
THOUSAND_SEPARATOR = "'"

# Characters that separate the table columns.
COLUMNS_GAP = '  '

# Maximum quotes or ratios to display on a line.
MAX_PER_LINE = 6

# Names to use for the columns labels.
SYMBOL_LABEL = 'SYM'
QUANTITY_LABEL = 'QTY'
SHARE_LABEL = 'VALUE'
PRICE_LABEL = 'PRICE'
VALUE_LABEL = 'VALUE'
WEIGHT_LABEL = 'WGT'

# Which columns should have a sum of all values displayed at the bottom.
COLUMNS_WITH_TOTAL = (WEIGHT_LABEL, VALUE_LABEL)

from datetime import datetime

# Makes the Yahoo symbol of a future.
def makeFuture(prefix, suffix, months=0):
    monthCodes = 'FGHJKMNQUVXZ'
    now = datetime.now()
    # now.month is the 0-based month
    m = now.month + months
    y = now.year
    if m > 12:
        y = y + m / 12
        m = m % 12
    return prefix + monthCodes[m - 1] + str(y % 100) + suffix

# Ratios to be displayed.
RATIOS = (
    ('XAU', 'XAG'),
    ('XBT', 'XAU'),
    ('XPT', 'USD'),
    ('XPD', 'USD'),
    ('EUR', 'USD'),
    ('USD', 'CNY'),
    ('GBP', 'EUR'),
    ('GBP', 'USD'),
    ('USD', 'JPY'),
    ('USD', 'SEK'),
)

from collections import OrderedDict

# Quotes, mapped to more user-friendly names.
QUOTES = OrderedDict([
    ('GBTC',      'GBTC'),
    ('^NYXBT',    'NYXBT'),
    ('DX-Y.NYB',  'USDX'),
    ('^FVX',      'USTNO5Y'),
    ('^TNX',      'USTNO10Y'),
    ('^TYX',      'USTNO30Y'),
    ('^VIX',      'VIX'),
    ('^SPG1200',  'S&P1200'),
    ('^GSPC',     'S&P500'),
    ('^IXIC',     'NASDAQ'),
    ('^HSI',      'HSI'),
    ('^N225',     'Nikkei225'),
    ('^STOXX50E', 'ESTX50EUR'),
    ('^GDAXI',    'DAX'),
    ('^FTSE',     'FTSE100'),
    ('^FCHI',     'CAC40'),
    ('FTSEMIB.MI','MIB'),
    ('FTSE.AT',   'ATHEX'),
    ('AAPL',      'AAPL'),
    ('GOOG',      'GOOG'),
    ('MSFT',      'MSFT'),
    ('AMZN',      'AMZN'),
    ('FB',        'FB'),
    ('FCAU',      'FCAU'),
    (makeFuture('GC',  '.CMX'), 'Gold'),
    (makeFuture('SI',  '.CMX'), 'Silver'),
    (makeFuture('PL',  '.NYM'), 'Platinum'),
    (makeFuture('PA',  '.NYM'), 'Palladium'),
    (makeFuture('ALI', '.CMX'), 'Aluminum'),
    (makeFuture('HG',  '.CMX'), 'Copper'),
    (makeFuture('CL',  '.NYM'), 'Oil'),
    (makeFuture('NG',  '.NYM'), 'Gas'),
    (makeFuture('C',   '.CBT'), 'Corn'),
    (makeFuture('O',   '.CBT'), 'Oats'),
    (makeFuture('LC',  '.CME'), 'Cattle'),
    (makeFuture('LH',  '.CME'), 'Hogs'),
    (makeFuture('CT',  '.NYB'), 'Cotton'),
    (makeFuture('KC',  '.NYB'), 'Coffee'),
    (makeFuture('CC',  '.NYB'), 'Cocoa'),
])

######################## END OF USER EDITABLE VARIABLES ########################

# Symbols that represent metals.
METALS = frozenset({'XAG', 'XAU', 'XPD', 'XPT'})

# Weight unit for the prices given by the echanges.
PRICE_WEIGHT_UNIT = 'ozt'

# Character to be used for the lines that separate the totals.
# Try '\u2012' for a better looking line.
LINE_CHAR = '-'

# This constant is created to avoid running the same code many times.
TRANS = str.maketrans(dict((() if FRACT_SEPARATOR    == '.'
                            else (('.', FRACT_SEPARATOR),)) +
                           (() if THOUSAND_SEPARATOR == ','
                            else ((',', THOUSAND_SEPARATOR),))))

# An alternative name that will map to the name as used by Yahoo finance.
ALIASES = {
    'XBT': 'BTC'
}

################################################################################

import json, itertools
from decimal import Decimal as D
from urllib.request import Request, urlopen
from urllib.parse import urlencode

def first(coll):
    return coll[0]

def second(coll):
    return coll[1]

# Partitions a collection coll in slices of size n.
def partition(coll, n):
    return tuple(coll[i:i+n] for i in range(0, len(coll), n))

# Returns the amount of grams in the named unit.
def toGram(unit):
    table = {'mg' :       '0.001',
             'g'  :       '1',
             'kg' :    '1000',
             't'  : '1000000',
             'ozt':      '31.1034768'}
    if unit not in table:
        raise Exception('Invalid weight unit \'' + unit + '\'')
    return D(table[unit])

# Valid names are: mg g kg t ozt.
def convertWeight(val, fromName, toName):
    fromNameLC = fromName.lower()
    toNameLC = toName.lower()
    return val if fromNameLC == toNameLC \
           else val * toGram(fromNameLC) / toGram(toNameLC)

# The only function that exchanges data with the net.
def retrieveData(url):
    print('sent ' + str(len(url)), end='', flush=True)
    response = urlopen(Request(url,
                               headers = {'User-Agent': 'https://github.com/andrea-chiavazza/finarm'}))
    data = str(response.read(), encoding = 'utf8')
    print(' received ' + str(len(data)), flush=True)
    return data

# Returns the amount of symbol in the portfolio, to the given unit if it's a metal.
def getPortfolioQuantity(portfolio, symbol, toUnit):
    if symbol not in portfolio:
        return D(0)
    vals = portfolio[symbol]
    if symbol in METALS:
        return sum(convertWeight(D(qty), unit, toUnit)
                   for unit, qty in vals.items())
    else:
        return D(vals)

# Returns the fractional digits required for a number n to have the given significant digits.
def significantDigits(n, signif):
    intlength = len(str(round(abs(n))))
    return (signif - intlength) if signif > intlength else 0

# Formats a number with the given fractional digits.
def formatFract(val, fractDigits):
    if val == 0:
        return ''
    if isinstance(val, D):
        return ('{:' + (',' if THOUSAND_SEPARATOR
                else '') + '.' + str(fractDigits) + 'f}').format(val).translate(TRANS)
    else:
        raise Exception('Unsupported type for value \'' + str(val) + '\'')

# Formats a number with the given significant digits.
def formatSignif(n, signif):
    return formatFract(n, significantDigits(n, signif))

# Returns a map of symbols to Decimal with the prices retrieved from Yahoo Finance.
def getYahooQuotes(ratios, quotes):
    symbols = tuple(makeYahooSymbolRatio(ratioNum, ratioDen)
                    for ratioNum, ratioDen in ratios) \
              + quotes
    params = {'q': 'select Symbol,LastTradePriceOnly from yahoo.finance.quotes where symbol in ("' +
            ','.join(symbols) + '")',
            'env': 'store://datatables.org/alltableswithkeys',
            'format': 'json'}
    text = retrieveData('https://query.yahooapis.com/v1/public/yql?' + urlencode(params))
    data = json.loads(text)['query']['results']['quote']
    return {entry['Symbol']: D(entry['LastTradePriceOnly'] if entry['LastTradePriceOnly'] else D(0))
            for entry in data}

# Returns the Yahoo symbol for a ratio of 2 symbols.
def makeYahooSymbolRatio(sym1, sym2):
    return ALIASES.get(sym1, sym1) + ALIASES.get(sym2, sym2) + '=X'

# Returns a map of Yahoo symbols to their current prices.
def getPrices(portfolio, priceCurs, totalCurs, ratios, quotes):
    ratiosNeeded = frozenset(itertools.product(portfolio.keys(),
                                               priceCurs + totalCurs)) \
                   | frozenset(ratios)
    prices = getYahooQuotes((ratio for ratio in ratiosNeeded
                                  if first(ratio) != second(ratio)),
                            tuple(quotes.keys()))
    prices.update({makeYahooSymbolRatio(ratioNum, ratioDen): D(1)
                       for (ratioNum, ratioDen) in ratiosNeeded
                       if ratioNum == ratioDen})
    return prices

# Returns a string padded on the left with spaces, if its length is smaller than n.
def leftPad(s, n):
    return ('{:>' + str(n) + '}').format(s)

def formatColumn(titles, data, signif, sortedSymbols):
    withTotal = first(titles) in COLUMNS_WITH_TOTAL
    if isinstance(first(tuple(data.values())), dict):
        return tuple(formatColumn(titles + (unit,), data[unit], signif, sortedSymbols)
                     for unit in data)
    if withTotal:
        tot = sum(data.values())
        fract = min(tuple(significantDigits(data[sym], signif)
                          for sym in sortedSymbols) + (significantDigits(tot, signif),))
        rows = tuple(formatFract(data[sym], fract)
                     for sym in sortedSymbols)
        totSep = LINE_CHAR
        totStr = formatFract(tot, fract)
    else:
        rows = tuple(formatSignif(data[sym], signif)
                     for sym in sortedSymbols)
        totSep = ' '
        totStr = ''
    maxl = max(len(s) for s in titles + rows + (totStr,))

    return (tuple(leftPad(s, maxl)
                  for s in titles),) + \
           tuple(leftPad(s, maxl)
                 for s in rows) + \
           (totSep * maxl, leftPad(totStr, maxl))

def convertPrice(qty, fromCur, toCur, symbolsToPrice):
    return qty * symbolsToPrice[makeYahooSymbolRatio(fromCur, toCur)]

def formatRatio(ratio, symbolsToPrice, signif):
    return first(ratio) + '/' + second(ratio) + '=' + \
           formatSignif(symbolsToPrice[makeYahooSymbolRatio(first(ratio),
                                                            second(ratio))],
                        signif)

def formatQuote(quote, symbolsToPrice, signif):
    return second(quote) + '=' + formatSignif(symbolsToPrice[first(quote)], signif)

def formatPrices(ratios, symbolsToPrice, formatter, columns, signif, gap):
    fquotes = tuple(formatter(ratio, symbolsToPrice, signif)
                    for ratio in ratios)
    return '\n'.join(gap.join(part)
                     for part in partition(fquotes, columns))

def computeColumn(symbols, func, units):
    if not units:
        return {sym: func(sym) for sym in symbols}
    else:
        return OrderedDict((unit, {sym: func(sym, unit) for sym in symbols})
                           for unit in units)

def formatCols(portfolio, symbolsToPrice):
    symbols = tuple(portfolio.keys())
    symCol = {sym: sym for sym in symbols}
    priceCols = computeColumn(symbols,
                              lambda sym, cur: convertPrice(1, sym, cur, symbolsToPrice),
                              PRICE_CURS)
    quantityCol = computeColumn(symbols,
                                lambda sym: getPortfolioQuantity(portfolio, sym, PRICE_WEIGHT_UNIT),
                                None)
    weightCols = computeColumn(symbols,
                               lambda sym, unit: getPortfolioQuantity(portfolio, sym, unit) if sym in METALS
                                                 else D(0),
                               WEIGHT_UNITS)
    valueCols = computeColumn(symbols,
                              lambda sym, cur: convertPrice(quantityCol[sym], sym, cur, symbolsToPrice),
                              TOTAL_CURS)
    shareCur = first(TOTAL_CURS)
    shareCurTot = sum(valueCols[shareCur].values())
    shareCol = computeColumn(symbols,
                             lambda sym: 100 * valueCols[shareCur][sym] / shareCurTot,
                             None)
    sortedSymbols = tuple(sorted(symbols,
                                 key = lambda sym: shareCol[sym],
                                 reverse = DISPLAY_HIGHEST_TO_LOWEST))

    fsym = ((SYMBOL_LABEL,),) + sortedSymbols + ('   ', '   ')
    fprice = formatColumn((PRICE_LABEL,), priceCols, SIGNIF_DIGITS, sortedSymbols)
    fqty = formatColumn((QUANTITY_LABEL,), quantityCol, SIGNIF_DIGITS, sortedSymbols)
    fwgt = formatColumn((WEIGHT_LABEL,), weightCols, SIGNIF_DIGITS, sortedSymbols)
    fshare = formatColumn((SHARE_LABEL, '%'), shareCol, SIGNIF_DIGITS, sortedSymbols)
    fvalues = formatColumn((VALUE_LABEL,), valueCols, SIGNIF_DIGITS, sortedSymbols)
    return (fsym,) + fprice + (fqty,) + fwgt + (fshare,) + fvalues

def formatPortfolio(portfolio, symbolsToPrice, gap):
    if not portfolio:
        return ''
    cols = formatCols(portfolio, symbolsToPrice)
    titles = tuple(first(a) for a in cols)
    titleRowsNo = max(len(a) for a in titles)
    # returns: titles + empty-line + rows
    return '\n'.join(gap.join(title[titleRow] if len(title) > titleRow
                              else ' ' * len(title[titleRow - 1])
                              for title in titles)
                     for titleRow in range(0, titleRowsNo)) + \
           '\n\n' + \
           '\n'.join(gap.join(col[row] for col in cols)
                     for row in range(1, len(second(cols))))

def formatAll(symbolsToPrice, portfolio, ratios, quotes):
    return (formatPrices(ratios, symbolsToPrice, formatRatio, MAX_PER_LINE, SIGNIF_DIGITS, COLUMNS_GAP) + '\n'
            + formatPrices(quotes.items(), symbolsToPrice, formatQuote, MAX_PER_LINE, SIGNIF_DIGITS, COLUMNS_GAP) + '\n'
            + '\n'
            + formatPortfolio(portfolio, symbolsToPrice, COLUMNS_GAP)
           )

def main():
    print(datetime.now().replace(microsecond = 0).isoformat(' '), end=' - ', flush=True)
    symbolsToPrice = getPrices(PORTFOLIO, PRICE_CURS, TOTAL_CURS, RATIOS, QUOTES)
    print(formatAll(symbolsToPrice, PORTFOLIO, RATIOS, QUOTES))

#################################### TESTS #####################################

def assertEquals(actual, expected):
    if actual != expected:
        raise Exception('Error: expected:\n"' + str(expected).replace('\n', '\\n\n') + '"\n' +
                        'but was:\n"' + str(actual).replace('\n', '\\n\n') + '"\n')

def runTests():
    assertEquals(first((2, 8, 7)), 2)
    assertEquals(second([2, 8, 7]), 8)
    assertEquals(partition([2, 8, 7, 2, 3, 0, 9, 1, 8, 7, 10], 3),
                 ([2, 8, 7], [2, 3, 0], [9, 1, 8], [7, 10]))
    assertEquals(toGram('mg'), D('0.001'))
    assertEquals(toGram('g'), D('1'))
    assertEquals(toGram('kg'), D('1000'))
    assertEquals(toGram('kg'), D('1000'))
    assertEquals(toGram('t'), D('1000000'))
    assertEquals(toGram('ozt'), D('31.1034768'))
    assertEquals(convertWeight(D('2.3'), 'g', 'kg'), D('0.0023'))
    assertEquals(convertWeight(D('2.38'), 'ozt', 'kg'), D('0.074026274784'))
    assertEquals(convertWeight(D('2.38'), 'ozt', 'ozt'), D('2.38'))
    assertEquals(getPortfolioQuantity({'XBT': 23, 'XAU': {'g': 8, 'ozt': 2}}, 'XXX', 'ozt'),
                 D(0))
    assertEquals(getPortfolioQuantity({'XBT': 23, 'XAU': {'g': 8, 'ozt': 2}}, 'XBT', 'ozt'),
                 D(23))
    assertEquals(getPortfolioQuantity({'XBT': 23, 'XAU': {'g': 8, 'ozt': 2}}, 'XAU', 'ozt'),
                 D('2.257205972549023844176802768'))
    assertEquals(getPortfolioQuantity({'XBT': 23, 'XAU': {'g': 8, 'ozt': 2}}, 'XAU', 'g'),
                 D('70.2069536'))
    assertEquals(significantDigits(23.9, 4), 2)
    assertEquals(significantDigits(23.9, 6), 4)
    assertEquals(significantDigits(23, 6), 4)
    assertEquals(significantDigits(123, 3), 0)
    assertEquals(significantDigits(8123, 3), 0)
    assertEquals(significantDigits(8123, 6), 2)
    assertEquals(significantDigits(8123, 0), 0)
    assertEquals(formatFract(D('2.98'), 5), '2.98000')
    assertEquals(formatFract(D('2.26'), 1), '2.3')
    assertEquals(formatFract(D('2.25'), 1), '2.2')
    assertEquals(formatFract(D('2.95'), 0), '3')
    assertEquals(formatFract(D('23882.95'), 0), "23'883")
    assertEquals(formatSignif(D('2.8'), 3), '2.80')
    assertEquals(formatSignif(D('92.8'), 3), '92.8')
    assertEquals(formatSignif(D('3392.8'), 3), "3'393")
    assertEquals(makeYahooSymbolRatio('EUR', 'USD'), 'EURUSD=X')
    assertEquals(leftPad('abc', 5), '  abc')
    assertEquals(leftPad('abc', 3), 'abc')
    assertEquals(leftPad('abc', 1), 'abc')
    assertEquals(leftPad('abc', 0), 'abc')
    assertEquals(leftPad('', 3), '   ')
    assertEquals(
            formatColumn(('VALUE',),
                         OrderedDict([('USD', {'XAU': D('25258.00195184353152442430487'),
                                       'XAG': D('4507.029573556921456446309564'),
                                       'XBT': D('132440.0000'),
                                       'GBP': D('21468.3800')}),
                                      ('EUR', {'XAU': D('22977.48491554484481297602074'),
                                       'XAG': D('4100.099340106327920227876261'),
                                       'XBT': D('120482.2388'),
                                       'GBP': D('19529.8300')}),
                                      ('GBP', {'XAU': D('16648.10616873010158144121046'),
                                       'XAG': D('2970.691518040823011786257927'),
                                       'XBT': D('87294.1916'),
                                       'GBP': D('14150.0')}),
                                      ('XBT', {'XAU': D('58.73937536124193035551575379'),
                                       'XAG': D('10.47163231607856778249304914'),
                                       'XBT': D('308.0'),
                                       'GBP': D('49.5250')}),
                                      ('XAU', {'XAU': D('23.51550316715718417691491004'),
                                       'XAG': D('4.195157045882407589880755710'),
                                       'XBT': D('123.2924'),
                                       'GBP': D('19.8100')})]),
                                      4,
                                      ('XBT', 'XAU', 'GBP', 'XAG')),
            ((('  VALUE', '    USD'), "132'440", " 25'258", " 21'468", "  4'507", '-------', "183'673"),
             (('  VALUE', '    EUR'), "120'482", " 22'977", " 19'530", "  4'100", '-------', "167'090"),
             (('  VALUE', '    GBP'), " 87'294", " 16'648", " 14'150", "  2'971", '-------', "121'063"),
             (('VALUE', '  XBT'), '308.0', ' 58.7', ' 49.5', ' 10.5', '-----', '426.7'),
             (('VALUE', '  XAU'), '123.3', ' 23.5', ' 19.8', '  4.2', '-----', '170.8')))
    assertEquals(
            formatColumn(('VALUE', 'USD'),
                         {'XAU': D('25258.00195184353152442430487'),
                          'XAG': D('4507.029573556921456446309564'),
                          'XBT': D('132440.0000'),
                          'GBP': D('21468.3800')},
                         4,
                         ('XBT', 'XAU', 'GBP', 'XAG')),
            (('  VALUE', '    USD'), "132'440", " 25'258", " 21'468", "  4'507", '-------', "183'673"))
    assertEquals(convertPrice(23, 'EUR', 'GBP', {'EURGBP=X': D('1.2')}), D('27.6'))
    assertEquals(formatRatio(('EUR', 'USD'), {'EURUSD=X': D('1.2')}, 4), 'EUR/USD=1.200')
    assertEquals(formatQuote(('^GSPC', 'S&P500'), {'^GSPC': D('1.2')}, 4), 'S&P500=1.200')
    assertEquals(formatPrices((('EUR', 'USD'), ('GBP', 'EUR'), ('GBP', 'USD')),
                               {'GBPEUR=X': D('0.78'),
                                'EURUSD=X': D('1.2'),
                                'GBPUSD=X': D('12.2')},
                               formatRatio,
                               2,
                               4,
                               '  '),
                 'EUR/USD=1.200  GBP/EUR=0.780\nGBP/USD=12.20')
    assertEquals(computeColumn(('XBT', 'EUR', 'XAU'), lambda sym: sym + 'x', None),
                 {'XBT': 'XBTx', 'EUR': 'EURx', 'XAU': 'XAUx'})
    assertEquals(computeColumn(('XBT', 'EUR', 'XAU'), lambda sym, unit: sym + 'x' + unit, ('u1', 'u2', 'u3')),
                 OrderedDict([('u1', {'EUR': 'EURxu1', 'XAU': 'XAUxu1', 'XBT': 'XBTxu1'}),
                              ('u2', {'EUR': 'EURxu2', 'XAU': 'XAUxu2', 'XBT': 'XBTxu2'}),
                              ('u3', {'EUR': 'EURxu3', 'XAU': 'XAUxu3', 'XBT': 'XBTxu3'})]))
    assertEquals(
            formatCols({'XAU': {'g': 8, 'ozt': 2},
                        'XBT': D('13.3'),
                        'GBP': D('2168')},
                       {'XAUUSD=X': D('2.3'),
                        'BTCUSD=X': D('0.89'),
                        'GBPUSD=X': D('1.29'),
                        'XAUEUR=X': D('2.198'),
                        'BTCEUR=X': D('10.2'),
                        'GBPEUR=X': D('3.287'),
                        'XAUGBP=X': D('833.2'),
                        'GBPGBP=X': D('1.0'),
                        'BTCGBP=X': D('81.032'),
                        'GBPBTC=X': D('0.332'),
                        'XAUBTC=X': D('340.2'),
                        'BTCBTC=X': D('1'),
                        'XAUXAU=X': D('1'),
                        'GBPXAU=X': D('3.987'),
                        'BTCXAU=X': D('35.834')}),
            ((('SYM',), 'GBP', 'XBT', 'XAU', '   ', '   '),
             (('PRICE', '  USD'), '1.290', '0.890', '2.300', '     ', '     '),
             (('PRICE', '  EUR'), '3.287', '10.20', '2.198', '     ', '     '),
             (('PRICE', '  GBP'), '1.000', '81.03', '833.2', '     ', '     '),
             (('  QTY',),         "2'168", '13.30', '2.257', '     ', '     '),
             (('  WGT', '    g'), '     ', '     ', '70.21', '-----', '70.21'),
             (('VALUE', '    %'), ' 99.4', '  0.4', '  0.2', '-----', '100.0'),
             (('VALUE', '  USD'), "2'797", '   12', '    5', '-----', "2'814"),
             (('VALUE', '  EUR'), "7'126", '  136', '    5', '-----', "7'267"),
             (('VALUE', '  GBP'), "2'168", "1'078", "1'881", '-----', "5'126"),
             (('VALUE', '  XBT'), '  720', '   13', '  768', '-----', "1'501"),
             (('VALUE', '  XAU'), "8'644", '  477', '    2', '-----', "9'123")))
    assertEquals(
            formatPortfolio({'XAU': {'g': 8, 'ozt': 2},
                             'XBT': D('13.3'),
                             'GBP': D('2168')},
                            {'XAUUSD=X': D('2.3'),
                             'BTCUSD=X': D('0.89'),
                             'GBPUSD=X': D('1.29'),
                             'XAUEUR=X': D('2.198'),
                             'BTCEUR=X': D('10.2'),
                             'GBPEUR=X': D('3.287'),
                             'XAUGBP=X': D('833.2'),
                             'GBPGBP=X': D('1.0'),
                             'BTCGBP=X': D('81.032'),
                             'GBPBTC=X': D('0.332'),
                             'XAUBTC=X': D('340.2'),
                             'BTCBTC=X': D('1'),
                             'XAUXAU=X': D('1'),
                             'GBPXAU=X': D('3.987'),
                             'BTCXAU=X': D('35.834')},
                            '  '),
            "SYM  PRICE  PRICE  PRICE    QTY    WGT  VALUE  VALUE  VALUE  VALUE  VALUE  VALUE\n" +
            "       USD    EUR    GBP             g      %    USD    EUR    GBP    XBT    XAU\n" +
            "\n" +
            "GBP  1.290  3.287  1.000  2'168          99.4  2'797  7'126  2'168    720  8'644\n" +
            "XBT  0.890  10.20  81.03  13.30           0.4     12    136  1'078     13    477\n" +
            "XAU  2.300  2.198  833.2  2.257  70.21    0.2      5      5  1'881    768      2\n" +
            "                                 -----  -----  -----  -----  -----  -----  -----\n" +
            "                                 70.21  100.0  2'814  7'267  5'126  1'501  9'123")
    assertEquals(
            formatAll({'XAUUSD=X': D('2.3'),
                       'BTCUSD=X': D('0.89'),
                       'GBPUSD=X': D('1.29'),
                       'XAUEUR=X': D('2.198'),
                       'BTCEUR=X': D('10.2'),
                       'GBPEUR=X': D('3.287'),
                       'XAUGBP=X': D('833.2'),
                       'GBPGBP=X': D('1.0'),
                       'BTCGBP=X': D('81.032'),
                       'GBPBTC=X': D('0.332'),
                       'XAUBTC=X': D('340.2'),
                       'BTCBTC=X': D('1'),
                       'XAUXAU=X': D('1'),
                       'GBPXAU=X': D('3.987'),
                       'BTCXAU=X': D('35.834'),
                       'XAUXAG=X': D('83.2'),
                       'XBTXAU=X': D('3.7'),
                       'GBTC':     D('98.7'),
                       '^NYXBT':   D('928.2'),
                       'DX-Y.NYB': D('25.18')},
                      {'XAU': {'g': 8, 'ozt': 2},
                       'XBT': D('13.3'),
                       'GBP': D('2168')},
                      (('XAU', 'XAG'),
                       ('XBT', 'XAU')),
                      OrderedDict([('GBTC',     'GBTC'),
                                   ('^NYXBT',   'NYXBT'),
                                   ('DX-Y.NYB', 'USDX')])),
            "XAU/XAG=83.20  XBT/XAU=35.83\n" +
            "GBTC=98.70  NYXBT=928.2  USDX=25.18\n" +
            "\n" +
            "SYM  PRICE  PRICE  PRICE    QTY    WGT  VALUE  VALUE  VALUE  VALUE  VALUE  VALUE\n" +
            "       USD    EUR    GBP             g      %    USD    EUR    GBP    XBT    XAU\n" +
            "\n" +
            "GBP  1.290  3.287  1.000  2'168          99.4  2'797  7'126  2'168    720  8'644\n" +
            "XBT  0.890  10.20  81.03  13.30           0.4     12    136  1'078     13    477\n" +
            "XAU  2.300  2.198  833.2  2.257  70.21    0.2      5      5  1'881    768      2\n" +
            "                                 -----  -----  -----  -----  -----  -----  -----\n" +
            "                                 70.21  100.0  2'814  7'267  5'126  1'501  9'123")

######### EXECUTION STARTING POINT #########
runTests()
main ()
